// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: bucket.sql

package db

import (
	"context"
	"time"
)

const BucketExists = `-- name: BucketExists :one
SELECT COUNT(*) > 0 as bucket_exists
FROM buckets
WHERE name = ?
`

func (q *Queries) BucketExists(ctx context.Context, name string) (bool, error) {
	row := q.queryRow(ctx, q.bucketExistsStmt, BucketExists, name)
	var bucket_exists bool
	err := row.Scan(&bucket_exists)
	return bucket_exists, err
}

const BucketPolicyExists = `-- name: BucketPolicyExists :one
SELECT COUNT(*) > 0 as policy_exists
FROM bucket_policies
WHERE bucket_name = ?
`

func (q *Queries) BucketPolicyExists(ctx context.Context, bucketName string) (bool, error) {
	row := q.queryRow(ctx, q.bucketPolicyExistsStmt, BucketPolicyExists, bucketName)
	var policy_exists bool
	err := row.Scan(&policy_exists)
	return policy_exists, err
}

const CountObjectsInBucket = `-- name: CountObjectsInBucket :one
SELECT COUNT(*) as count
FROM objects
WHERE bucket_name = ?
`

func (q *Queries) CountObjectsInBucket(ctx context.Context, bucketName string) (int64, error) {
	row := q.queryRow(ctx, q.countObjectsInBucketStmt, CountObjectsInBucket, bucketName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateBucket = `-- name: CreateBucket :exec
INSERT INTO buckets (name, region)
VALUES (?, ?)
`

type CreateBucketParams struct {
	Name   string `json:"name"`
	Region string `json:"region"`
}

func (q *Queries) CreateBucket(ctx context.Context, arg CreateBucketParams) error {
	_, err := q.exec(ctx, q.createBucketStmt, CreateBucket, arg.Name, arg.Region)
	return err
}

const CreateBucketTag = `-- name: CreateBucketTag :exec
INSERT INTO bucket_tags (bucket_name, key, value)
VALUES (?, ?, ?)
ON CONFLICT(bucket_name, key) DO UPDATE SET value = excluded.value
`

type CreateBucketTagParams struct {
	BucketName string `json:"bucket_name"`
	Key        string `json:"key"`
	Value      string `json:"value"`
}

func (q *Queries) CreateBucketTag(ctx context.Context, arg CreateBucketTagParams) error {
	_, err := q.exec(ctx, q.createBucketTagStmt, CreateBucketTag, arg.BucketName, arg.Key, arg.Value)
	return err
}

const DeleteBucket = `-- name: DeleteBucket :exec
DELETE FROM buckets
WHERE name = ?
`

func (q *Queries) DeleteBucket(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteBucketStmt, DeleteBucket, name)
	return err
}

const DeleteBucketPolicy = `-- name: DeleteBucketPolicy :exec
DELETE FROM bucket_policies
WHERE bucket_name = ?
`

func (q *Queries) DeleteBucketPolicy(ctx context.Context, bucketName string) error {
	_, err := q.exec(ctx, q.deleteBucketPolicyStmt, DeleteBucketPolicy, bucketName)
	return err
}

const DeleteBucketTag = `-- name: DeleteBucketTag :exec
DELETE FROM bucket_tags
WHERE bucket_name = ? AND key = ?
`

type DeleteBucketTagParams struct {
	BucketName string `json:"bucket_name"`
	Key        string `json:"key"`
}

func (q *Queries) DeleteBucketTag(ctx context.Context, arg DeleteBucketTagParams) error {
	_, err := q.exec(ctx, q.deleteBucketTagStmt, DeleteBucketTag, arg.BucketName, arg.Key)
	return err
}

const DeleteBucketTags = `-- name: DeleteBucketTags :exec
DELETE FROM bucket_tags
WHERE bucket_name = ?
`

func (q *Queries) DeleteBucketTags(ctx context.Context, bucketName string) error {
	_, err := q.exec(ctx, q.deleteBucketTagsStmt, DeleteBucketTags, bucketName)
	return err
}

const GetBucket = `-- name: GetBucket :one
SELECT name, region, created_at
FROM buckets
WHERE name = ?
`

func (q *Queries) GetBucket(ctx context.Context, name string) (Bucket, error) {
	row := q.queryRow(ctx, q.getBucketStmt, GetBucket, name)
	var i Bucket
	err := row.Scan(&i.Name, &i.Region, &i.CreatedAt)
	return i, err
}

const GetBucketPolicy = `-- name: GetBucketPolicy :one
SELECT policy, created_at, updated_at
FROM bucket_policies
WHERE bucket_name = ?
`

type GetBucketPolicyRow struct {
	Policy    string    `json:"policy"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) GetBucketPolicy(ctx context.Context, bucketName string) (GetBucketPolicyRow, error) {
	row := q.queryRow(ctx, q.getBucketPolicyStmt, GetBucketPolicy, bucketName)
	var i GetBucketPolicyRow
	err := row.Scan(&i.Policy, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const GetBucketTags = `-- name: GetBucketTags :many
SELECT key, value
FROM bucket_tags
WHERE bucket_name = ?
ORDER BY key ASC
`

type GetBucketTagsRow struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) GetBucketTags(ctx context.Context, bucketName string) ([]GetBucketTagsRow, error) {
	rows, err := q.query(ctx, q.getBucketTagsStmt, GetBucketTags, bucketName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBucketTagsRow{}
	for rows.Next() {
		var i GetBucketTagsRow
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListBuckets = `-- name: ListBuckets :many
SELECT name, region, created_at
FROM buckets
ORDER BY created_at ASC
`

func (q *Queries) ListBuckets(ctx context.Context) ([]Bucket, error) {
	rows, err := q.query(ctx, q.listBucketsStmt, ListBuckets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bucket{}
	for rows.Next() {
		var i Bucket
		if err := rows.Scan(&i.Name, &i.Region, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListBucketsFiltered = `-- name: ListBucketsFiltered :many
SELECT name, region, created_at
FROM buckets
WHERE (?1 IS NULL OR region = ?1)
  AND (?2 IS NULL OR name LIKE ?2 || '%')
ORDER BY created_at ASC
LIMIT ?3
`

type ListBucketsFilteredParams struct {
	Region interface{} `json:"region"`
	Prefix interface{} `json:"prefix"`
	Limit  int64       `json:"limit"`
}

func (q *Queries) ListBucketsFiltered(ctx context.Context, arg ListBucketsFilteredParams) ([]Bucket, error) {
	rows, err := q.query(ctx, q.listBucketsFilteredStmt, ListBucketsFiltered, arg.Region, arg.Prefix, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bucket{}
	for rows.Next() {
		var i Bucket
		if err := rows.Scan(&i.Name, &i.Region, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const PutBucketPolicy = `-- name: PutBucketPolicy :exec
INSERT INTO bucket_policies (bucket_name, policy)
VALUES (?, ?)
ON CONFLICT(bucket_name) DO UPDATE SET
    policy = excluded.policy,
    updated_at = CURRENT_TIMESTAMP
`

type PutBucketPolicyParams struct {
	BucketName string `json:"bucket_name"`
	Policy     string `json:"policy"`
}

func (q *Queries) PutBucketPolicy(ctx context.Context, arg PutBucketPolicyParams) error {
	_, err := q.exec(ctx, q.putBucketPolicyStmt, PutBucketPolicy, arg.BucketName, arg.Policy)
	return err
}
