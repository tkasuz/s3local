// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: event.sql

package db

import (
	"context"
)

const CreateEvent = `-- name: CreateEvent :one
INSERT INTO events (bucket_name, object_id, event_type)
VALUES (?, ?, ?)
RETURNING id, bucket_name, object_id, event_type, event_time
`

type CreateEventParams struct {
	BucketName string `json:"bucket_name"`
	ObjectID   int64  `json:"object_id"`
	EventType  string `json:"event_type"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.queryRow(ctx, q.createEventStmt, CreateEvent, arg.BucketName, arg.ObjectID, arg.EventType)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.ObjectID,
		&i.EventType,
		&i.EventTime,
	)
	return i, err
}

const ListEventsByBucket = `-- name: ListEventsByBucket :many
SELECT id, bucket_name, object_id, event_type, event_time
FROM events
WHERE bucket_name = ?
ORDER BY event_time DESC
LIMIT ? OFFSET ?
`

type ListEventsByBucketParams struct {
	BucketName string `json:"bucket_name"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

func (q *Queries) ListEventsByBucket(ctx context.Context, arg ListEventsByBucketParams) ([]Event, error) {
	rows, err := q.query(ctx, q.listEventsByBucketStmt, ListEventsByBucket, arg.BucketName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.BucketName,
			&i.ObjectID,
			&i.EventType,
			&i.EventTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
