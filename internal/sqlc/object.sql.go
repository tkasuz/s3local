// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: object.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const CopyObject = `-- name: CopyObject :one
INSERT INTO objects (
    bucket_name,
    key,
    data,
    size,
    etag,
    content_type,
    content_encoding,
    content_disposition,
    cache_control,
    expires,
    storage_class,
    server_side_encryption
)
SELECT ?, ?, o.data, o.size, o.etag, o.content_type, o.content_encoding,
       o.content_disposition, o.cache_control, o.expires, ?, ?
FROM objects o
WHERE o.bucket_name = ? AND o.key = ?
RETURNING id, bucket_name, key, size, etag, content_type, content_encoding,
          content_disposition, cache_control, expires, storage_class,
          server_side_encryption, version_id, created_at, updated_at
`

type CopyObjectParams struct {
	BucketName           string         `json:"bucket_name"`
	Key                  string         `json:"key"`
	StorageClass         string         `json:"storage_class"`
	ServerSideEncryption sql.NullString `json:"server_side_encryption"`
	BucketName_2         string         `json:"bucket_name_2"`
	Key_2                string         `json:"key_2"`
}

type CopyObjectRow struct {
	ID                   int64          `json:"id"`
	BucketName           string         `json:"bucket_name"`
	Key                  string         `json:"key"`
	Size                 int64          `json:"size"`
	ETag                 string         `json:"etag"`
	ContentType          string         `json:"content_type"`
	ContentEncoding      sql.NullString `json:"content_encoding"`
	ContentDisposition   sql.NullString `json:"content_disposition"`
	CacheControl         sql.NullString `json:"cache_control"`
	Expires              sql.NullTime   `json:"expires"`
	StorageClass         string         `json:"storage_class"`
	ServerSideEncryption sql.NullString `json:"server_side_encryption"`
	VersionID            sql.NullString `json:"version_id"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

func (q *Queries) CopyObject(ctx context.Context, arg CopyObjectParams) (CopyObjectRow, error) {
	row := q.queryRow(ctx, q.copyObjectStmt, CopyObject,
		arg.BucketName,
		arg.Key,
		arg.StorageClass,
		arg.ServerSideEncryption,
		arg.BucketName_2,
		arg.Key_2,
	)
	var i CopyObjectRow
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.Key,
		&i.Size,
		&i.ETag,
		&i.ContentType,
		&i.ContentEncoding,
		&i.ContentDisposition,
		&i.CacheControl,
		&i.Expires,
		&i.StorageClass,
		&i.ServerSideEncryption,
		&i.VersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateObject = `-- name: CreateObject :one
INSERT INTO objects (
    bucket_name,
    key,
    data,
    size,
    etag,
    content_type,
    content_encoding,
    content_disposition,
    cache_control,
    expires,
    storage_class,
    server_side_encryption,
    version_id
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, bucket_name, key, size, etag, content_type, content_encoding,
          content_disposition, cache_control, expires, storage_class,
          server_side_encryption, version_id, created_at, updated_at
`

type CreateObjectParams struct {
	BucketName           string         `json:"bucket_name"`
	Key                  string         `json:"key"`
	Data                 []byte         `json:"data"`
	Size                 int64          `json:"size"`
	ETag                 string         `json:"etag"`
	ContentType          string         `json:"content_type"`
	ContentEncoding      sql.NullString `json:"content_encoding"`
	ContentDisposition   sql.NullString `json:"content_disposition"`
	CacheControl         sql.NullString `json:"cache_control"`
	Expires              sql.NullTime   `json:"expires"`
	StorageClass         string         `json:"storage_class"`
	ServerSideEncryption sql.NullString `json:"server_side_encryption"`
	VersionID            sql.NullString `json:"version_id"`
}

type CreateObjectRow struct {
	ID                   int64          `json:"id"`
	BucketName           string         `json:"bucket_name"`
	Key                  string         `json:"key"`
	Size                 int64          `json:"size"`
	ETag                 string         `json:"etag"`
	ContentType          string         `json:"content_type"`
	ContentEncoding      sql.NullString `json:"content_encoding"`
	ContentDisposition   sql.NullString `json:"content_disposition"`
	CacheControl         sql.NullString `json:"cache_control"`
	Expires              sql.NullTime   `json:"expires"`
	StorageClass         string         `json:"storage_class"`
	ServerSideEncryption sql.NullString `json:"server_side_encryption"`
	VersionID            sql.NullString `json:"version_id"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

func (q *Queries) CreateObject(ctx context.Context, arg CreateObjectParams) (CreateObjectRow, error) {
	row := q.queryRow(ctx, q.createObjectStmt, CreateObject,
		arg.BucketName,
		arg.Key,
		arg.Data,
		arg.Size,
		arg.ETag,
		arg.ContentType,
		arg.ContentEncoding,
		arg.ContentDisposition,
		arg.CacheControl,
		arg.Expires,
		arg.StorageClass,
		arg.ServerSideEncryption,
		arg.VersionID,
	)
	var i CreateObjectRow
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.Key,
		&i.Size,
		&i.ETag,
		&i.ContentType,
		&i.ContentEncoding,
		&i.ContentDisposition,
		&i.CacheControl,
		&i.Expires,
		&i.StorageClass,
		&i.ServerSideEncryption,
		&i.VersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateObjectMetadata = `-- name: CreateObjectMetadata :exec
INSERT INTO object_metadata (object_id, key, value)
VALUES (?, ?, ?)
`

type CreateObjectMetadataParams struct {
	ObjectID int64  `json:"object_id"`
	Key      string `json:"key"`
	Value    string `json:"value"`
}

// Object Metadata queries
func (q *Queries) CreateObjectMetadata(ctx context.Context, arg CreateObjectMetadataParams) error {
	_, err := q.exec(ctx, q.createObjectMetadataStmt, CreateObjectMetadata, arg.ObjectID, arg.Key, arg.Value)
	return err
}

const CreateObjectTag = `-- name: CreateObjectTag :exec
INSERT INTO object_tags (object_id, key, value)
VALUES (?, ?, ?)
`

type CreateObjectTagParams struct {
	ObjectID int64  `json:"object_id"`
	Key      string `json:"key"`
	Value    string `json:"value"`
}

// Object Tags queries
func (q *Queries) CreateObjectTag(ctx context.Context, arg CreateObjectTagParams) error {
	_, err := q.exec(ctx, q.createObjectTagStmt, CreateObjectTag, arg.ObjectID, arg.Key, arg.Value)
	return err
}

const DeleteAllObjectTags = `-- name: DeleteAllObjectTags :exec
DELETE FROM object_tags
WHERE object_id = ?
`

func (q *Queries) DeleteAllObjectTags(ctx context.Context, objectID int64) error {
	_, err := q.exec(ctx, q.deleteAllObjectTagsStmt, DeleteAllObjectTags, objectID)
	return err
}

const DeleteObject = `-- name: DeleteObject :exec
DELETE FROM objects
WHERE bucket_name = ? AND key = ?
`

type DeleteObjectParams struct {
	BucketName string `json:"bucket_name"`
	Key        string `json:"key"`
}

func (q *Queries) DeleteObject(ctx context.Context, arg DeleteObjectParams) error {
	_, err := q.exec(ctx, q.deleteObjectStmt, DeleteObject, arg.BucketName, arg.Key)
	return err
}

const DeleteObjectMetadata = `-- name: DeleteObjectMetadata :exec
DELETE FROM object_metadata
WHERE object_id = ?
`

func (q *Queries) DeleteObjectMetadata(ctx context.Context, objectID int64) error {
	_, err := q.exec(ctx, q.deleteObjectMetadataStmt, DeleteObjectMetadata, objectID)
	return err
}

const DeleteObjectTags = `-- name: DeleteObjectTags :exec
DELETE FROM object_tags
WHERE object_id = ?
`

func (q *Queries) DeleteObjectTags(ctx context.Context, objectID int64) error {
	_, err := q.exec(ctx, q.deleteObjectTagsStmt, DeleteObjectTags, objectID)
	return err
}

const GetObject = `-- name: GetObject :one
SELECT id, bucket_name, key, data, size, etag, content_type, content_encoding,
       content_disposition, cache_control, expires, storage_class,
       server_side_encryption, version_id, created_at, updated_at
FROM objects
WHERE bucket_name = ? AND key = ?
`

type GetObjectParams struct {
	BucketName string `json:"bucket_name"`
	Key        string `json:"key"`
}

func (q *Queries) GetObject(ctx context.Context, arg GetObjectParams) (Object, error) {
	row := q.queryRow(ctx, q.getObjectStmt, GetObject, arg.BucketName, arg.Key)
	var i Object
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.Key,
		&i.Data,
		&i.Size,
		&i.ETag,
		&i.ContentType,
		&i.ContentEncoding,
		&i.ContentDisposition,
		&i.CacheControl,
		&i.Expires,
		&i.StorageClass,
		&i.ServerSideEncryption,
		&i.VersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetObjectID = `-- name: GetObjectID :one
SELECT id
FROM objects
WHERE bucket_name = ? AND key = ?
`

type GetObjectIDParams struct {
	BucketName string `json:"bucket_name"`
	Key        string `json:"key"`
}

func (q *Queries) GetObjectID(ctx context.Context, arg GetObjectIDParams) (int64, error) {
	row := q.queryRow(ctx, q.getObjectIDStmt, GetObjectID, arg.BucketName, arg.Key)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const GetObjectMetadata = `-- name: GetObjectMetadata :one
SELECT id, bucket_name, key, size, etag, content_type, content_encoding,
       content_disposition, cache_control, expires, storage_class,
       server_side_encryption, version_id, created_at, updated_at
FROM objects
WHERE bucket_name = ? AND key = ?
`

type GetObjectMetadataParams struct {
	BucketName string `json:"bucket_name"`
	Key        string `json:"key"`
}

type GetObjectMetadataRow struct {
	ID                   int64          `json:"id"`
	BucketName           string         `json:"bucket_name"`
	Key                  string         `json:"key"`
	Size                 int64          `json:"size"`
	ETag                 string         `json:"etag"`
	ContentType          string         `json:"content_type"`
	ContentEncoding      sql.NullString `json:"content_encoding"`
	ContentDisposition   sql.NullString `json:"content_disposition"`
	CacheControl         sql.NullString `json:"cache_control"`
	Expires              sql.NullTime   `json:"expires"`
	StorageClass         string         `json:"storage_class"`
	ServerSideEncryption sql.NullString `json:"server_side_encryption"`
	VersionID            sql.NullString `json:"version_id"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

func (q *Queries) GetObjectMetadata(ctx context.Context, arg GetObjectMetadataParams) (GetObjectMetadataRow, error) {
	row := q.queryRow(ctx, q.getObjectMetadataStmt, GetObjectMetadata, arg.BucketName, arg.Key)
	var i GetObjectMetadataRow
	err := row.Scan(
		&i.ID,
		&i.BucketName,
		&i.Key,
		&i.Size,
		&i.ETag,
		&i.ContentType,
		&i.ContentEncoding,
		&i.ContentDisposition,
		&i.CacheControl,
		&i.Expires,
		&i.StorageClass,
		&i.ServerSideEncryption,
		&i.VersionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetObjectMetadataByObjectID = `-- name: GetObjectMetadataByObjectID :many
SELECT key, value
FROM object_metadata
WHERE object_id = ?
`

type GetObjectMetadataByObjectIDRow struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) GetObjectMetadataByObjectID(ctx context.Context, objectID int64) ([]GetObjectMetadataByObjectIDRow, error) {
	rows, err := q.query(ctx, q.getObjectMetadataByObjectIDStmt, GetObjectMetadataByObjectID, objectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetObjectMetadataByObjectIDRow{}
	for rows.Next() {
		var i GetObjectMetadataByObjectIDRow
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetObjectTags = `-- name: GetObjectTags :many
SELECT key, value
FROM object_tags
WHERE object_id = ?
`

type GetObjectTagsRow struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) GetObjectTags(ctx context.Context, objectID int64) ([]GetObjectTagsRow, error) {
	rows, err := q.query(ctx, q.getObjectTagsStmt, GetObjectTags, objectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetObjectTagsRow{}
	for rows.Next() {
		var i GetObjectTagsRow
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListObjects = `-- name: ListObjects :many
SELECT id, bucket_name, key, size, etag, content_type, content_encoding,
       content_disposition, cache_control, expires, storage_class,
       server_side_encryption, version_id, created_at, updated_at
FROM objects
WHERE bucket_name = ?
  AND (? = '' OR key >= ?)
  AND (? = '' OR key LIKE ? || '%')
ORDER BY key ASC
LIMIT ?
`

type ListObjectsParams struct {
	BucketName string         `json:"bucket_name"`
	Column2    interface{}    `json:"column_2"`
	Key        string         `json:"key"`
	Column4    interface{}    `json:"column_4"`
	Column5    sql.NullString `json:"column_5"`
	Limit      int64          `json:"limit"`
}

type ListObjectsRow struct {
	ID                   int64          `json:"id"`
	BucketName           string         `json:"bucket_name"`
	Key                  string         `json:"key"`
	Size                 int64          `json:"size"`
	ETag                 string         `json:"etag"`
	ContentType          string         `json:"content_type"`
	ContentEncoding      sql.NullString `json:"content_encoding"`
	ContentDisposition   sql.NullString `json:"content_disposition"`
	CacheControl         sql.NullString `json:"cache_control"`
	Expires              sql.NullTime   `json:"expires"`
	StorageClass         string         `json:"storage_class"`
	ServerSideEncryption sql.NullString `json:"server_side_encryption"`
	VersionID            sql.NullString `json:"version_id"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

func (q *Queries) ListObjects(ctx context.Context, arg ListObjectsParams) ([]ListObjectsRow, error) {
	rows, err := q.query(ctx, q.listObjectsStmt, ListObjects,
		arg.BucketName,
		arg.Column2,
		arg.Key,
		arg.Column4,
		arg.Column5,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListObjectsRow{}
	for rows.Next() {
		var i ListObjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.BucketName,
			&i.Key,
			&i.Size,
			&i.ETag,
			&i.ContentType,
			&i.ContentEncoding,
			&i.ContentDisposition,
			&i.CacheControl,
			&i.Expires,
			&i.StorageClass,
			&i.ServerSideEncryption,
			&i.VersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListObjectsWithDelimiter = `-- name: ListObjectsWithDelimiter :many
SELECT id, bucket_name, key, size, etag, content_type, content_encoding,
       content_disposition, cache_control, expires, storage_class,
       server_side_encryption, version_id, created_at, updated_at
FROM objects
WHERE bucket_name = ?
  AND (? = '' OR key >= ?)
  AND (? = '' OR key LIKE ? || '%')
ORDER BY key ASC
`

type ListObjectsWithDelimiterParams struct {
	BucketName string         `json:"bucket_name"`
	Column2    interface{}    `json:"column_2"`
	Key        string         `json:"key"`
	Column4    interface{}    `json:"column_4"`
	Column5    sql.NullString `json:"column_5"`
}

type ListObjectsWithDelimiterRow struct {
	ID                   int64          `json:"id"`
	BucketName           string         `json:"bucket_name"`
	Key                  string         `json:"key"`
	Size                 int64          `json:"size"`
	ETag                 string         `json:"etag"`
	ContentType          string         `json:"content_type"`
	ContentEncoding      sql.NullString `json:"content_encoding"`
	ContentDisposition   sql.NullString `json:"content_disposition"`
	CacheControl         sql.NullString `json:"cache_control"`
	Expires              sql.NullTime   `json:"expires"`
	StorageClass         string         `json:"storage_class"`
	ServerSideEncryption sql.NullString `json:"server_side_encryption"`
	VersionID            sql.NullString `json:"version_id"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

func (q *Queries) ListObjectsWithDelimiter(ctx context.Context, arg ListObjectsWithDelimiterParams) ([]ListObjectsWithDelimiterRow, error) {
	rows, err := q.query(ctx, q.listObjectsWithDelimiterStmt, ListObjectsWithDelimiter,
		arg.BucketName,
		arg.Column2,
		arg.Key,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListObjectsWithDelimiterRow{}
	for rows.Next() {
		var i ListObjectsWithDelimiterRow
		if err := rows.Scan(
			&i.ID,
			&i.BucketName,
			&i.Key,
			&i.Size,
			&i.ETag,
			&i.ContentType,
			&i.ContentEncoding,
			&i.ContentDisposition,
			&i.CacheControl,
			&i.Expires,
			&i.StorageClass,
			&i.ServerSideEncryption,
			&i.VersionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ObjectExists = `-- name: ObjectExists :one
SELECT COUNT(*) > 0 as object_exists
FROM objects
WHERE bucket_name = ? AND key = ?
`

type ObjectExistsParams struct {
	BucketName string `json:"bucket_name"`
	Key        string `json:"key"`
}

func (q *Queries) ObjectExists(ctx context.Context, arg ObjectExistsParams) (bool, error) {
	row := q.queryRow(ctx, q.objectExistsStmt, ObjectExists, arg.BucketName, arg.Key)
	var object_exists bool
	err := row.Scan(&object_exists)
	return object_exists, err
}

const UpdateObject = `-- name: UpdateObject :exec
UPDATE objects
SET data = ?,
    size = ?,
    etag = ?,
    content_type = ?,
    content_encoding = ?,
    content_disposition = ?,
    cache_control = ?,
    expires = ?,
    storage_class = ?,
    server_side_encryption = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE bucket_name = ? AND key = ?
`

type UpdateObjectParams struct {
	Data                 []byte         `json:"data"`
	Size                 int64          `json:"size"`
	ETag                 string         `json:"etag"`
	ContentType          string         `json:"content_type"`
	ContentEncoding      sql.NullString `json:"content_encoding"`
	ContentDisposition   sql.NullString `json:"content_disposition"`
	CacheControl         sql.NullString `json:"cache_control"`
	Expires              sql.NullTime   `json:"expires"`
	StorageClass         string         `json:"storage_class"`
	ServerSideEncryption sql.NullString `json:"server_side_encryption"`
	BucketName           string         `json:"bucket_name"`
	Key                  string         `json:"key"`
}

func (q *Queries) UpdateObject(ctx context.Context, arg UpdateObjectParams) error {
	_, err := q.exec(ctx, q.updateObjectStmt, UpdateObject,
		arg.Data,
		arg.Size,
		arg.ETag,
		arg.ContentType,
		arg.ContentEncoding,
		arg.ContentDisposition,
		arg.CacheControl,
		arg.Expires,
		arg.StorageClass,
		arg.ServerSideEncryption,
		arg.BucketName,
		arg.Key,
	)
	return err
}
